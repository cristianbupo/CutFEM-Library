/*
This file is part of CutFEM-Library.

CutFEM-Library is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

CutFEM-Library is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
CutFEM-Library. If not, see <https://www.gnu.org/licenses/>
*/
/*

 This file is part of Freefem++

 Freefem++ is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.

 Freefem++  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with Freefem++; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef COMMON_MESH2DN_HPP_
#define COMMON_MESH2DN_HPP_

#include "dataStruct2D.hpp"
#include "GenericMesh.hpp"
#include <cstdlib>

class Mesh2 : public GenericMesh<Triangle2, BoundaryEdge2, Vertex2> {
  public:
    static const int D = 2;

    Mesh2() : GenericMesh<Triangle2, BoundaryEdge2, Vertex2>() {}
    Mesh2(const std::string filename, MeshFormat type_mesh); // build from mesh generated by Freefem
    Mesh2(int nx, int ny, R orx, R ory, R lx, R ly);         // build structured mesh
    void init(int nx, int ny, R orx, R ory, R lx, R ly);     // build structured mesh

  private:
    Mesh2(const Mesh2 &);          // no copy constructor
    void operator=(const Mesh2 &); // no copy allowed

    void readMeshGmsh(std::ifstream &f);
    void readMeshFreefem(std::ifstream &f);

    friend Mesh2 refine(const Mesh2 &Th);
    friend Mesh2 refine_barycentric(const Mesh2 &Th);
};

class BarycentricMesh2 : public Mesh2 {
    public:
        BarycentricMesh2(int nx, int ny, R orx, R ory, R lx, R ly);  
        
        int get_macro_element(int i) const {
            assert(0 <= i && i < this->nt);  
            return inverse_macro_map[i];
        }

        int get_local_subelement(int i) const {
            assert(0 <= i && i < this->nt);
            return local_subelement_map[i];
        }

        int element_adj(int k_macro, int iface_adj) const;

        // Maps each base mesh triangle to its 3 refined children
        std::vector<std::array<int, 3>> macro_elements;
    private:

        // Maps each refined triangle to its parent macro triangle
        std::vector<int> inverse_macro_map;

        // Optionally, which local subtriangle (0, 1, or 2) each refined element is
        std::vector<int> local_subelement_map;

};

class MeshQuad2 : public GenericMesh<Quad2, BoundaryEdge2, Vertex2> {
  public:
    static const int D = 2;
    MeshQuad2(int nx, int ny, R orx, R ory, R lx, R ly); // build structured mesh

  private:
    MeshQuad2(const MeshQuad2 &);      // no copy constructor
    void operator=(const MeshQuad2 &); // no copy allowed
};

#endif
